
# 第4章 
## 4.1 数组
1. Go语言中声明变量时，总会使用对应类型的零值来进行初始化
2. 	*array4[0] = 100  //相当于*(array4[0])
3. go语言中，数组是一个值，意味着可以用于赋值操作中
4. 只有数组的元素类型一致且数组长度一致才可以互相赋值
5. 复制指针数组，只会复制指针数组的值，而不会复制指针数组指向的值。此时两个指针数组指向同一块内存
6. 因为数组是一个值，所以我们函数传递数组时，将会将值复制后传递，建议传入指向数组的指针
7. 切片有容量限制，可以使用append进行扩容



## 4.2 切片



1. 切片的增大是通过内置函数append来进行的，并且切片的缩小是通过在切片基础上继续切片而造成的。
2. 切片是有3个字段的数据结构，分别是指向底层数组的指针，切片的长度(切片目前元素的个数)，切片的容量(切片允许增长到的个数)
3. 使用`	slice := make([]string, 5)`创建切片时将会创建一个长度和容量大小都为5的切片
4. 如果创建切片时，指定切片的长度和容量，底层数组的长度就是指定的容量，但是初始化后并不能访问所有的元素。如果此时访问长度以外的元素将会`panic index out of`
5. 如果基于这个切片继续切片创建一个新的切片，新切片将会和原来的切片共享底层数组，此时如果使用切片修改元素，那么其他切片也都会修改，因为共享底层数组。也就是当两个切片共享同一个底层数组时，如果一个切片修改了底层数组，那么另外一个切片也会感知。
6. **nil切片的3个字段中，指向底层数组的指针为nil，长度为0，容量为0。但是空切片的底层数组指针不为nil，只是底层数组长度为0（底层数组为空，但底层数组指针非空）。nil切片只是声明了一个切片，并没有分配底层数组内存，而空切片底层分配了数组的内存，只是长度为0**

```go
	var nums []int  //nil切片
	nums2 := make([]int, 0)  //空切片
	nums3 := []int{}  //空切片
	fmt.Println(nums, nums2)
	fmt.Println(nums == nil, nums2 == nil, nums3 == nil ) // true false false

```

7. append内置函数添加元素到切片中，会返回一个包含修改结果的**新切片**，并且这个新切片的长度总是会改变，只是容量偶尔改变。
8. append内置函数在切片的容量小于1000时，会成倍的增加容量，一旦元素个数超过1000，容量的增长因子会设置为1.25，也就是每次增加25%
9. 注意的是，使用for-range迭代获取到的切片的值只是一个副本，而不是指向对应切片值的引用。也就是每次都会赋值给对应的迭代的index以及value，这两个变量内存不会改变，只是不断地将值拷贝到这里
10. 由于切片的尺寸很小，在函数之间复制和传递切片成本很低。64位的机器上，每个切片都需要24字节的内存，指针，长度，容量分别为8字节，因为指针是一个指向底层数组，所以函数传递切片时，只是将这24字节的内容拷贝，不会设计底层数组
11. 将切片作为参数传递时，如果对传进去的切片修改会起作用，如果对其进行添加元素或切片将会不起作用

 ```go
   //使用函数传递切片
   func sliceDemo(nums []int) {
   	nums [0] = 100  //修改可以起到作用
   	//nums = append(nums, 1, 2, 3)   //添加元素不起作用
   	//nums = nums[1:]  //切片也不起作用
   	fmt.Println(nums)
   }
 ```

   




## 4.3 映射
1. 映射可以通过make或使用字面量创建，使用字面量创建时，映射的长度会通过字面量的个数来确定
2. 映射的键可以是任何值，这个值的类型可以是内置类型，也可以是结构类型，只要这个值可以使用==运算符做比较
3. 切片，函数以及包含切片的结构类型这些类型由于具有引用意义，不能作为映射的键，使用这些类型会造成编译错误。
4. 切片可以作为映射的值
5. 可以通过声明一个未经初始化的映射来创建一个值为nil的映射，nil映射不能用于存储键值对，否则会报运行时错误
6. 从映射取值时有两个选择，第一个选择便是对应的值，第2个选择是这个键是否存在
```go
colors := map[string]string{"red": "blue"}
//val 将会取得该键对应的值，如果键不存在，将会取得值对应类型的零值，
//exist判断键是否存在，如果存在将会返回true
val, exist := colors["red"]
if exist {
    fmt.Println(val)
}

//上面的26-29行代码等价于
if val, exist := colors["red"]; exist {
    fmt.Println(val)
}
```

7. go语言中，通过键获取值，即使键不存在也会返回一个值，返回的是该值对应类型的零值
8. 从colors这个map中删除键为red的键值对 `delete(colors, "red")`
9. 映射通过函数进行传递时，将会以引用的方式传递，不会进行值拷贝，如果在函数中对map进行了修改，其他函数传递过去的map也会进行修改
10. 映射的增长没有容量或任何限制
11. len()可以用于切片和映射，但是cap()只能够用于切片
12. 映射是一个存储键值对数据的无序集合，也就是说，存储的时候顺序与遍历时候的顺序可能不一致。无序的原因是映射的实现使用了散列表

```go
package main

import "fmt"


func demp01(mymap map[string]string) {

	if _, exist := mymap["red"]; exist {
		delete(mymap, "red")
	}
}

func main() {

	//使用函数进行删除
	colors2 := map[string]string{"red": "blue", "green":"yellow", "1": "2"}
	fmt.Println("删除前--------------------------------->")
	for key, val := range colors2 {
		fmt.Printf("key = %s, value = %s\n", key, val)
	}
	demp01(colors2)
	fmt.Println("删除后--------------------------------->")
	for key, val := range colors2 {
		fmt.Printf("key = %s, value = %s\n", key, val)
	}

}

```

